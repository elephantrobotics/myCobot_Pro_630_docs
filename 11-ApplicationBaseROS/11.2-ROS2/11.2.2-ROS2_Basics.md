# 1 ROS2 project structure

## 1.1 colcon workspace

The colocn workspace is the directory where software packages are created, modified, and compiled. Colcon's workspace can be intuitively described as a warehouse, which contains various ROS projects to facilitate system organization, management and calling.

- **Create workspace**:
  
```bash
mkdir -p ~/colcon_ws/src # Create folder
cd ~/colcon_ws/ # Enter the folder
colcon build # Build the code in the workspace.
```

**Note:** colcon supports option `--symlink-install`. This allows for faster iteration by changing installed files by changing files in the source space (such as Python files or other uncompiled resources). Avoid the need to recompile every time you modify your python script.

```bash
colcon build --symlink-install
```

A ROS2 workspace is a directory with a specific structure. There is usually a `src` subdirectory. In this subdirectory is where the source code for the ROS2 package resides. Typically, directories start out empty in other ways.

colcon will do the source code build. By default, it will create the following directories as siblings of the `src` directory:

```bash
src/: colcon package for ROS2 (source code package)
 
build/: The location where intermediate files are stored. For each package, a subfolder is created in which CMake is called, for example.
 
install/: The installation location of each package. By default, each package will be installed into a separate subdirectory.

log/: Contains various logging information about each colcon call.
```

The directory structure of a ROS2 workspace is as follows:

```bash
WorkSpace --- Customized workspace.
     |--- build: The directory where intermediate files are stored. A separate subdirectory will be created for each function package in this directory.
     |--- install: Installation directory, a separate subdirectory will be created for each function package in this directory.
     |--- log: Log directory, used to store log files.
     |--- src: Directory used to store function package source code.
         |-- C++ function package
             |-- package.xml: package information, such as: package name, version, author, dependencies.
             |-- CMakeLists.txt: Configure compilation rules, such as source files, dependencies, and target files.
             |-- src: C++ source file directory.
             |-- include: header file directory.
             |-- msg: message interface file directory.
             |-- srv: Service interface file directory.
             |-- action: Action interface file directory.
         |-- Python function package
             |-- package.xml: package information, such as: package name, version, author, dependencies.
             |-- setup.py: similar to CMakeLists.txt of C++ function package.
             |-- setup.cfg: Function package basic configuration file.
             |-- resource: resource directory.
             |-- test: stores test-related files.
             |-- Directory with the same name of the function package: Python source file directory.
```

## 1.2 ROS2 software package

Package is not only a software package on Linux, but also the basic unit of colcon compilation. The object we use `colcon build` to compile is each ROS2 package.

**Create your own package:**

- The command syntax for creating a software package using Python is:

```bash
ros2 pkg create --build-type ament_python <package_name>
```

- For example:
  
```bash
ros2 pkg create --build-type ament_python --node-name my_node my_package
```

# 2 Basic tool commands

In this chapter, you will learn about the common command tools of ROS2.

## 2.1 Topics

ROS 2 breaks complex systems into many modular nodes. Topics are an important element of the ROS graph and serve as a bus for nodes to exchange messages.
Topics are one of the main ways data moves between nodes and therefore between different parts of the system.

Specific reference: [Official Tutorial](https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics.html)

- **topics help**

```bash
ros2 topics -h
```

- **Launch turtlesim and keyboard control**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

- **Node Relationship Diagram**

```bash
rqt_graph
```

- **Understand topics related commands**

```bash
ros2 topics -h
```

- **Topic List**

```bash
ros2 topic list
ros2 topic list -t # Display the corresponding message type
```

- **View topic content**

```bash
ros2 topic echo <topic_name>
ros2 topic echo /turtle1/cmd_vel
```

- **Display topic related information, type**

```bash
ros2 topic info <topic_name>
# Output /turtle1/cmd_vel topic interface related information
ros2 topic info /turtle1/cmd_vel
```

- **Display interface related information**

```bash
ros2 interface show <msg_type>
# Output geometry_msgs/msg/Twist interface related information
ros2 interface show geometry_msgs/msg/Twist
```

- **Issue a command**

```bash
ros2 topic pub <topic_name> <msg_type> '<args>'
# Issue speed command
ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"
# Issue speed commands at a certain frequency
ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}} "
```

- **Check the frequency of topic postings**

```bash
ros2 topic hz <topic_name>
#Output/turtle1/cmd_vel release frequency
ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}} "
```

## 2.2 Nodes

Each node in ROS should be responsible for a single module purpose (e.g., one node to control the wheel motors, one node to control the laser rangefinder, etc.).  Each node can send and receive data to other nodes through topics, services, operations, or parameters.
A complete robot system consists of many nodes working together.  In ROS 2, a single executable (C++ program, Python program, etc.) can contain one or more nodes.

Specific reference: [Official Tutorial](https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Nodes/Understanding-ROS2-Nodes.html)

- **nodes help**

```bash
ros2 nodes -h
```

- **Launch turtlesim and keyboard control**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

- **View node list**

```bash
ros2 node list
```

- **View node relationship diagram**

```bash
rqt_graph
```

- **Remapping**

```bash
ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle
ros2 node list
```

- **View node information**

```bash
ros2 node info <node_name>
ros2 node info /my_turtle
```

## 2.3 Services

Services are another communication method for nodes in a ROS graph.  Services are based on a call-and-response model rather than the publisher-subscriber model of topics.  While topics allow nodes to subscribe to a data stream and get continuous updates, services only provide data when specifically called by a client.

Specific reference: [Official Tutorial](https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Services/Understanding-ROS2-Services.html)

- **services help**

```bash
ros2 service -h
```

- **Launch turtlesim and keyboard control**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

- **View service list**

```bash
ros2 service list
# Display service list and message type
ros2 service list -t
```

- **View the message types received by the service**

```bash
ros2 service type <service_name>
ros2 service type /clear
```

- **Find services that use a certain message type**

```bash
ros2 service find <type_name>
ros2 service find std_srvs/srv/Empty
```

- **View service message type definition**

```bash
ros2 interface show <type_name>.srv
ros2 interface show std_srvs/srv/Empty.srv
```

- **Call service command to clear walking track**

```bash
ros2 service call <service_name> <service_type>
ros2 service call /clear std_srvs/srv/Empty
```

- **Generate new turtle**

```bash
ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: 'turtle2'}"
```

## 2.4 Parameters

Parameters are configuration values for the node.  You can think of parameters as node settings.  Nodes can store parameters as integers, floats, booleans, strings, and lists.  In ROS 2, each node maintains its own parameters.  For more background information on parameters, see the concept documentation.

Specific reference: [Official Tutorial](https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters.html)

- **parameters help**

```bash
ros2 param -h
```

- **Launch turtlesim and keyboard control**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

- **View service list**

```bash
ros2 param list
```

- **Get parameter value**

```bash
ros2 param get <node_name> <parameter_name>
ros2 param get /turtlesim background_g
```

- **Set parameter values**

```bash
ros2 param set <node_name> <parameter_name> <value>
ros2 param set /turtlesim background_r 150
```

- **Export parameter values**

```bash
ros2 param dump <node_name>
ros2 param dump /turtlesim
```

- **Independent import parameters**

```bash
ros2 param load <node_name> <parameter_file>
ros2 param load /turtlesim ./turtlesim.yaml
```

- **Start the node and import parameters at the same time**

```bash
ros2 run <package_name> <executable_name> --ros-args --params-file <file_name>
ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml
```

## 2.5 Actions

Actions are a communication type in ROS 2 used for long-running tasks.  They consist of three parts: goals, feedback, and results.

Actions are based on topics and services.  They function like services, except that operations are preemptible (you can cancel them while executing).  They also provide steady feedback rather than services that return a single response.

Operations use a client-server model, similar to the publisher-subscriber model (described in the topic tutorial). The Action Client node sends the goal to the Action Server node, which acknowledges the goal and returns a feedback stream and results.

Specific reference: [Official Tutorial](https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Actions/Understanding-ROS2-Actions.html)


- **action help**

```bash
ros2 action -h
```

- **Launch turtlesim and keyboard control**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

Press G|B|V|C|D|E|R|T to rotate, press F on the keyboard to cancel l

- **View the server and client of node actions**

```bash
ros2 node info /turtlesim
```

- **View action list**

```bash
ros2 action list
ros2 action list -t # Display action type
```

- **View action information**

```bash
ros2 action info <action>
ros2 action info /turtle1/rotate_absolute
```

- **View action message content**

```bash
ros2 interface show turtlesim/action/RotateAbsolute
```

- **Send action target information**

```bash
ros2 action send_goal <action_name> <action_type>
ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 1.57}"
# With feedback information
ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 0}" --feedback
```

## 2.6 RQt

RQt is a graphical user interface framework that implements various tools and interfaces in the form of plug-ins.  All existing GUI tools can be run as dockable windows in RQt!  These tools can still run in a traditional stand-alone way, but RQt makes it easier to manage all the different windows in a single screen layout.

Specific reference: [Official Tutorial](https://docs.ros.org/en/foxy/Concepts/About-RQt.html)

You can easily run any RQt tool/plugin via:

```bash
rqt
```

- **rqt help**
  
```bash
rqt -h
```

- **Launch turtlesim and keyboard control**

```bash
ros2 run turtlesim turtlesim_node
ros2 run turtlesim turtle_teleop_key
```

* Action Browser: / Plugins -> Actions -> Action Type Browser

* Parameter Reconfigure: / Plugins -> configuration -> Parameter Reconfigure

* Node graph: /Node Graph

* Control steering: /Plugins -> Robot Tools -> Robot Steering

* Service call: /Plugins -> Services -> Service Caller

* Service Type Browser: Plugins -> Services -> Service Type Browser

* Message publishing: Plugins -> Topics -> Message Publisher

* Message Type Browser: Plugins -> Topics -> Message Type Browser

* Topic list: Plugins -> Topics -> Topic Monitor

* Draw a curve graph: Plugins -> Visualization -> Plot

- **View logs: rqt_console**

```bash
ros2 run rqt_console rqt_console
ros2 run turtlesim turtlesim_node
ros2 topic pub -r 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0,y: 0.0,z: 0.0}}"
```

## 2.7 TF2

tf2 is a transformation library that allows users to track multiple coordinate systems over time. tf2 maintains the relationship between coordinate systems in a time-buffered tree structure, and allows users to transform points, vectors, etc. between any two coordinate systems at any desired time point.

Specific reference: [Official Tutorial](https://docs.ros.org/en/foxy/Tutorials/Intermediate/Tf2/Introduction-To-Tf2.html)

Let's start by installing the demo package and its dependencies.

```bash
sudo apt-get install ros-foxy-turtle-tf2-py ros-foxy-tf2-tools ros-foxy-tf-transformations
```

- **Follow**

- launch starts 2 little turtles, the first little turtle automatically follows the second one

```bash
ros2 launch turtle_tf2_py turtle_tf2_demo.launch.py
```

- Control the movement of the first little turtle through the keyboard

```bash
ros2 run turtlesim turtle_teleop_key
```

- **View TF tree**

```bash
ros2 run tf2_tools view_frames.py
evince frames.pdf
```

- **View the relationship between two coordinate systems**

```bash
ros2 run tf2_ros tf2_echo [reference_frame] [target_frame]
ros2 run tf2_ros tf2_echo turtle2 turtle1
```

- **View TF relationships on rviz**

```bash
ros2 run rviz2 rviz2 -d $(ros2 pkg prefix --share turtle_tf2_py)/rviz/turtle_rviz.rviz
```
## 2.8 URDF

URDF is the Unified Robot Description Format used to specify robot geometry and organization in ROS.

Specific reference: [Official Tutorial](https://docs.ros.org/en/foxy/Tutorials/Intermediate/URDF/Adding-Physical-and-Collision-Properties-to-a-URDF-Model.html)

- **Full syntax**
  
```bash
<robot>
     # describe:
     # Parameters: name=""
     # Child node:
         <link>
             # Description:
             # Parameters: name=""
             # Child node:
                 <visual>
                     # describe:
                     # Parameters:
                     # child nodes:
                         <geometry>
                             # description
                             #parameters
                             # Child node:
                                 <cylinder />
                                     # Description:
                                     # Parameters:
                                         # length="0.6"
                                         # radius="0.2"
                                 <box />
                                     # description
                                     # Parameters:size="0.6 0.1 0.2"
                                 <mesh />
                                     # Description
                                     #Parameters: filename="package://urdf_tutorial/meshes/l_finger_tip.dae"
                         <collision>
                             # Description: collision element, prioritized
                             #parameters
                             # child node
                                 <geometry>
                         <inertial>
                             # description
                             #parameters
                             # Child nodes:
                                 <mass />
                                     # description: mass
                                     # Parameters: value=10
                                 <inertia />
                                     # Description: Inertia
                                     # Parameters: i+"Cartesian product of xyz" (9 in total)="0.4"
                         <origin />
                             # Description:
                             # Parameters:
                                 # rpy="0 1.5 0"
                                 # xyz="0 0 -0.3"
                         <material />
                             # Description
                             # Parameters: name="blue"
         <joint>
             # Description
             # Parameters:
                 # name=""
                 # type=""
                     # fixed
                     #prismatic
             # child node
                 <parent />
                     # Description
                     # Parameters：link=""
                 <child />
                     # Description:
                     # Parameters：link=""
                 <origin />
                     # Description:
                     # Parameters：xyz="0 -0.2 0.25"
                 <limit />
                     # Description
                     # Parameters:
                         # effort="1000.0" maximum effort
                         # lower="-0.38" Joint upper limit (radians)
                         # upper="0" Joint lower limit (radians)
                         # velocity="0.5" Maximum velocity
                 <axis />
                     # Description: Press? axis rotation
                     # Parameters: xyz="0 0 1", along the Z axis
         <material>
             # Description:
             # Parameters: name="blue"
             # child node:
                 <color />
                     # description:
                     # Parameters: rgba="0 0 0.8 1"
```

- **Install dependent libraries**

```bash
sudo apt install ros-foxy-joint-state-publisher-gui ros-foxy-joint-state-publisher
sudo apt install ros-foxy-xacro
```

- **Download source code**

```bash
cd ~/dev_ws
git clone -b ros2 https://github.com/ros/urdf_tutorial.git src/urdf_tutorial
```

- **Compile source code**

```bash
colcon build --packages-select urdf_tutorial
```

- **Run Example**

```bash
ros2 launch urdf_tutorial display.launch.py model:=urdf/01-myfirst.urdf
```

## 2.9 Launch

The startup system in ROS 2 is responsible for helping users describe the configuration of their system and then execute it as described.  The configuration of a system includes the programs to run, where to run them, the arguments passed to them, and ROS-specific conventions that make it easy to reuse components throughout the system by providing different configurations for each component.  It is also responsible for monitoring the status of started processes and reporting and/or responding to changes in the status of those processes.

Launch files written in Python, XML or YAML can start and stop different nodes, as well as trigger and handle various events.

Specific reference: [Official Tutorial](https://docs.ros.org/en/foxy/Tutorials/Intermediate/Launch/Creating-Launch-Files.html)


**Setup**

Create a new directory to store your launch files:

```bash
mkdir launch
```

**Write startup file**

Let's put together a ROS 2 startup file using the turtlesim package and its executable.  As just mentioned.

Copy and paste the complete code into the launch/turtlesim_mimic_launch.py file:

```bash
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
     return LaunchDescription([
         Node(
             package='turtlesim',
             namespace='turtlesim1',
             executable='turtlesim_node',
             name='sim'
         ),
         Node(
             package='turtlesim',
             namespace='turtlesim2',
             executable='turtlesim_node',
             name='sim'
         ),
         Node(
             package='turtlesim',
             executable='mimic',
             name='mimic',
             remappings=[
                 ('/input/pose', '/turtlesim1/turtle1/pose'),
                 ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'),
             ]
         )
     ])
```

**Run ros2 startup file**

To run the launch file created above, go into the directory you created earlier and run the following command:

The syntax format is:

```bash
ros2 launch <package_name> <launch_file_name>
```

```bash
cd launch
ros2 launch turtlesim_mimic_launch.py
```

- **launch help**

```bash
ros2 launch -h
```

- **Run Node**

```bash
ros2 launch turtlesim multisim.launch.py
```

- **Check what parameters the launch file has**

```bash
ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py -s
ros2 launch turtlebot3_fake_node turtlebot3_fake_node.launch.py --show-arguments
ros2 launch turtlebot3_bringup robot.launch.launch.py -s
```

- **Run launch file with parameters**

```bash
ros2 launch turtlebot3_bringup robot.launch.launch.py usb_port:=/dev/opencr
```

- **Run node and debug**

```bash
ros2 launch turtlesim turtlesim_node.launch.py -d
```

- **Only output node description**

```bash
ros2 launch turtlesim turtlesim_node.launch.py -p
```

- **Run component**

```bash
ros2 launch composition composition_demo.launch.py
```

## 2.10 Run

run is used to run a single node, component program.

- **run help**

```bash
ros2 run -h
```

- **Run Node**

```bash
ros2 run turtlesim turtlesim_node
```

- **Run node with parameters**

```bash
ros2 run turtlesim turtlesim_node --ros-args -r __node:=turtle2 -r __ns:=/ns2
```

- **Run component container**

```bash
ros2 run rclcpp_components component_container
```

- **Run component**

```bash
ros2 run composition manual_composition
```


## 2.11 Package

A package can be thought of as a container for your ROS 2 code.  If you want to be able to install your code or share it with others, then you need to organize it in a package.  With packages, you can publish your ROS 2 creation and allow others to easily build and use it.

Package creation in ROS 2 uses ament as its build system and colcon as its build tool.  You can create packages using the officially supported CMake or Python, but other build types do exist.

Specific parameters: [Official Tutorial](https://docs.ros.org/en/foxy/Tutorials/Beginner-Client-Libraries/Creating-Your-First-ROS2-Package.html)

**Create workspace**

Create a new directory for each new workspace.  The name is not important, but it helps indicate the purpose of the workspace.  Let's choose the directory name ros2_ws for the "Development Workspace":

```bash
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws/src
```

- **pkg help**

```bash
ros2 pkg -h
```

- **List feature packages**

```bash
ros2 pkg executable turtlesim
```

- **Output a function package executable program**

```bash
ros2 pkg executable turtlesim
```

- **Create Python function package**

Before running the package creation command, make sure you are in the src folder.

```bash
cd ~/ros2_ws/src
```

The command syntax to create a new package in ROS 2 is:

```bash
ros2 pkg create --build-type ament_python <package_name>
# You will create a simple Hello World type executable in the package using the optional argument --node-name.
ros2 pkg create --build-type ament_python --node-name my_node my_package
```

- **Build package**

Placing packages in a workspace is particularly valuable because you can build many packages at once by running colcon build in the workspace root.  Otherwise, you will have to build each package individually.

```bash
# Return to the workspace directory:
cd ~/ros2_ws
# Now you can build your package:
colcon build
```

- **Source setup file**

To use your new package and executable, first open a new terminal and grab your main ROS 2 installation source.

Then, from the ros2_ws directory, run the following command to get your workspace:

```bash
source install/setup.bash
```

Now that your workspace has been added to your path, you will be able to use the new package's executables.

- **Use package**

To run the executable you created using the --node-name parameter during package creation, enter the following command:

```bash
ros2 run my_package my_node
```

---

[← Previous page](11.2.1-EnvironmentBuilding.md) | [Next page →](11.2.3-Rviz2Introduction.md)